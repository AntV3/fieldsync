{"version":3,"file":"imageUtils-D6AoaJeg.js","sources":["../../src/lib/imageUtils.js"],"sourcesContent":["/**\n * Image utilities for compression, optimization, and PDF generation\n */\n\n/**\n * Convert hex color to RGB array for PDF generation\n * @param {string} hex - Hex color string (with or without #)\n * @returns {number[]} RGB array [r, g, b]\n */\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? [\n        parseInt(result[1], 16),\n        parseInt(result[2], 16),\n        parseInt(result[3], 16)\n      ]\n    : [59, 130, 246] // Default to primary blue\n}\n\n/**\n * Load an image URL and convert to base64 for PDF embedding\n * Uses JPEG format for smaller file sizes (vs PNG)\n * @param {string} url - Image URL to load\n * @param {number} timeout - Timeout in milliseconds (default 5000)\n * @param {number} quality - JPEG quality 0-1 (default 0.85)\n * @returns {Promise<string|null>} Base64 data URL or null on failure\n */\nexport const loadImageAsBase64 = (url, timeout = 5000, quality = 0.85) => {\n  return new Promise((resolve) => {\n    if (!url) {\n      resolve(null)\n      return\n    }\n\n    const img = new Image()\n    img.crossOrigin = 'anonymous'\n\n    // Set timeout to prevent hanging\n    const timeoutId = setTimeout(() => {\n      img.src = ''\n      resolve(null)\n    }, timeout)\n\n    img.onload = () => {\n      clearTimeout(timeoutId)\n      try {\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        const ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 0, 0)\n        // Use JPEG for photos (smaller than PNG), fallback to PNG for transparency\n        const dataUrl = canvas.toDataURL('image/jpeg', quality)\n        resolve(dataUrl)\n      } catch (_e) {\n        // Canvas tainted or other error\n        resolve(null)\n      }\n    }\n\n    img.onerror = () => {\n      clearTimeout(timeoutId)\n      resolve(null)\n    }\n\n    img.src = url\n  })\n}\n\n/**\n * Load multiple images in parallel for faster PDF generation\n * @param {string[]} urls - Array of image URLs to load\n * @param {number} timeout - Timeout per image in milliseconds (default 5000)\n * @param {number} quality - JPEG quality 0-1 (default 0.85)\n * @returns {Promise<(string|null)[]>} Array of base64 data URLs (null for failed loads)\n */\nexport const loadImagesAsBase64 = async (urls, timeout = 5000, quality = 0.85) => {\n  if (!urls || urls.length === 0) {\n    return []\n  }\n\n  // Load all images in parallel\n  const results = await Promise.all(\n    urls.map(url => loadImageAsBase64(url, timeout, quality))\n  )\n\n  return results\n}\n\n/**\n * Compress an image file for faster uploads\n * @param {File} file - The image file to compress\n * @param {number} maxWidth - Maximum width in pixels (default 1920)\n * @param {number} quality - JPEG quality 0-1 (default 0.8)\n * @returns {Promise<File>} - Compressed image file\n */\nexport async function compressImage(file, maxWidth = 1920, quality = 0.8) {\n  // Skip compression for non-image files\n  if (!file.type.startsWith('image/')) {\n    return file\n  }\n\n  // Skip compression for small files (under 500KB)\n  if (file.size < 500 * 1024) {\n    return file\n  }\n\n  return new Promise((resolve) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const img = new Image()\n\n    img.onload = () => {\n      let { width, height } = img\n\n      // Calculate new dimensions, maintaining aspect ratio\n      if (width > maxWidth) {\n        height = Math.round((height * maxWidth) / width)\n        width = maxWidth\n      }\n\n      // Also limit height for very tall images\n      const maxHeight = 1920\n      if (height > maxHeight) {\n        width = Math.round((width * maxHeight) / height)\n        height = maxHeight\n      }\n\n      canvas.width = width\n      canvas.height = height\n\n      // Use high-quality rendering\n      ctx.imageSmoothingEnabled = true\n      ctx.imageSmoothingQuality = 'high'\n      ctx.drawImage(img, 0, 0, width, height)\n\n      // Convert to JPEG blob\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            // Create new file with original name but .jpg extension\n            const baseName = file.name.replace(/\\.[^/.]+$/, '')\n            const compressedFile = new File([blob], `${baseName}.jpg`, {\n              type: 'image/jpeg',\n              lastModified: Date.now()\n            })\n\n            resolve(compressedFile)\n          } else {\n            // Fallback to original if compression fails\n            console.warn('Image compression failed, using original')\n            resolve(file)\n          }\n        },\n        'image/jpeg',\n        quality\n      )\n\n      // Clean up object URL\n      URL.revokeObjectURL(img.src)\n    }\n\n    img.onerror = () => {\n      console.warn('Failed to load image for compression, using original')\n      URL.revokeObjectURL(img.src)\n      resolve(file)\n    }\n\n    // Load the image\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Compress multiple images in parallel\n * @param {File[]} files - Array of image files\n * @param {number} maxWidth - Maximum width in pixels\n * @param {number} quality - JPEG quality 0-1\n * @param {function} onProgress - Optional progress callback (completed, total)\n * @returns {Promise<File[]>} - Array of compressed files\n */\nexport async function compressImages(files, maxWidth = 1920, quality = 0.8, onProgress = null) {\n  let completed = 0\n  const total = files.length\n\n  const results = await Promise.all(\n    files.map(async (file) => {\n      const compressed = await compressImage(file, maxWidth, quality)\n      completed++\n      if (onProgress) {\n        onProgress(completed, total)\n      }\n      return compressed\n    })\n  )\n\n  return results\n}\n\n/**\n * Get the device's current GPS location using the browser Geolocation API.\n * Returns null silently if permission denied or unavailable (non-blocking).\n * @param {number} timeout - Max wait time in ms (default 5000)\n * @returns {Promise<{latitude: number, longitude: number, accuracy: number}|null>}\n */\nexport function getGPSLocation(timeout = 5000) {\n  return new Promise((resolve) => {\n    if (!navigator.geolocation) {\n      resolve(null)\n      return\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        resolve({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n          accuracy: Math.round(position.coords.accuracy)\n        })\n      },\n      () => resolve(null),\n      { enableHighAccuracy: true, timeout, maximumAge: 60000 }\n    )\n  })\n}\n\n/**\n * Get dimensions of an image file\n * @param {File} file - Image file\n * @returns {Promise<{width: number, height: number}>}\n */\nexport function getImageDimensions(file) {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = () => {\n      URL.revokeObjectURL(img.src)\n      resolve({ width: img.width, height: img.height })\n    }\n    img.onerror = () => {\n      URL.revokeObjectURL(img.src)\n      reject(new Error('Failed to load image'))\n    }\n    img.src = URL.createObjectURL(file)\n  })\n}\n"],"names":["hexToRgb","hex","result","loadImageAsBase64","url","timeout","quality","resolve","img","timeoutId","canvas","dataUrl","loadImagesAsBase64","urls","compressImage","file","maxWidth","ctx","width","height","maxHeight","blob","baseName","compressedFile","getGPSLocation","position"],"mappings":"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"}